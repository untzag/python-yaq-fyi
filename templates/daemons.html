{% include "header.html"  %}

{% include "title.html" %}
<h1> Python Implementation of yaq Daemons </h1>

<h2> Installation </h2>

<h2> Writing a daemon </h2>

<h3> Loading and saving state </h3>

<h3> Logging </h3>

<h3> Notes on async/await and yaq daemons </h3>

<h4> The <code>_busy</code> attribute </h4>

<h4> The <code>_update_state</code> async function </h4>

<h3> Using yaqd-cookiecutter-python </h3>

<h3> yaqd-core-python base classes </h3>

<h3> Implementing <a href=https://yaq.fyi/traits/is-daemon>is-daemon</a> </h3>

<h3> Implementing <a href=https://yaq.fyi/traits/has-position>has-position</a> </h3>
<p>
The <code>has-position</code> trait defines the <code>Hardware</code> class.
</p>

<h3> Implementing <a href=https://yaq.fyi/traits/has-limits>has-limits</a> </h3>
<p>
The <code>has-limits</code> trait defines the <code>ContinuousHardware</code> class.
</p>

<h3> Implementing <a href=https://yaq.fyi/traits/is-homeable>is-homeable</a> </h3>

<p>
Homeable hardware have a procedure which resets to a known position.
Homed devices are then returned to their destination.
This trait is required to be applied to a <code>Hardware</code> (or a subclass like <code>ContinuousHardware</code>) daemon, and introduces only one additional method:
</p>

<pre>
<code>
from yaqd_core import Hardware

class ExampleHomeable(Hardware):
    _kind = "example_homeable"
    traits = ["is-homeable"]

    def home(self):
        # Since homing is typically a long process, start a new asynchronous task
	# This may not be necessary, depending on how your device behaves,
	# but remember that home is defined as returning to the current destination
	# This method should return quickly, not wait for the homing to complete.
        loop = asyncio.get_event_loop()
        loop.create_task(self._home())

    async def _home(self):
        self._busy = True
        # Initiate the home
	...
	await self._not_busy_sig.wait()
	self.set_position(self._destination)
	

</code>
</pre>

<h3> Implementing <a href=https://yaq.fyi/traits/has-turret>has-turret</a> </h3>

<p>
Implementing <code>has-turret</code> involves writing two short methods, and storing one state variable:
</p>

<pre>
<code>
from yaqd_core import Base

class ExampleTurret(Base): # Often daemons implementing has-turret will be some kind of Hardware, but it is not required
    _kind = "example-turret"
    traits = ["has-turret"]

    def get_state(self):
        state = super().get_state()
        state["turret"] = self._turret
        return state

    def _load_state(self, state):
        super()._load_state(state)
        self._turret = state.get("turret", 0)

    def set_turret(self, index):
        self._busy = True
	# Perform the actual setting of the turret for your device

    def get_turret(self):
        return self._turret

</code>
</pre>

<h3> Implementing <a href=https://yaq.fyi/traits/is-sensor>is-sensor</a> </h3>

<p>
The <code>is-sensor</code> trait defines the <code>Sensor</code> class.
A lot of the machinery for making sensors work, including handling of looping and exposed methods, is implemented as part of the <code>Sensor</code> class.
That said, each sensor will have it's own configuration and you necessarily have to implement the function to actually perform a measurement.
</p>

<p>
As the implementor, you are responsible for filling out three attributes: <code>channel_names</code>, <code>channel_units</code>, and <code>channel_shapes</code>.
<code>channel_names</code> is a simple list of strings with names of each recorded value.
<code>channel_units</code> is a dictionary mapping the names to strings representing the units.
<code>channel_shapes</code> may be omitted if all channels are scalar values, otherwise it is a dictionary mapping names to tuples of integers representing the shapes.
</p>

<p>
A typical <code>is-sensor</code> daemon will look something like:
</p>

<pre>
<code>
from yaqd_core import Sensor

class ExampleSensor(Sensor):
    _kind = "example-sensor"

    def __init__(self, name, config, config_filepath):
        super().__init__(name, config, config_filepath)
	self.channel_names = ["channel0", "channel1"]
	self.channel_units = {"channel0": "V", "channel1": "A"}
	# If shaped, you would also include self.channel_shapes

    async def _measure(self):
        # Do whatever needs to be done to fill a dictionary mapping names to values
	# (or arrays for shaped data)
	return {"channel0": 1.234, "channel1": 3.14}
</code>
</pre>

<h3> Implementing <a href=https://yaq.fyi/traits/uses-serial>uses-serial</a> </h3>

<p>
The <code>uses-serial</code> trait is not typically going to be a terminal trait. 
More specific configuration will be provided by traits which depend on it.
These must also implement the <code>direct_serial_write</code> method.
See below for more in depth implementation for the cases of uart and i2c.
</p>

<h3> Implementing <a href=https://yaq.fyi/traits/uses-uart>uses-uart</a> </h3>
<p>
UART is the serial communication scheme used for RS-232 and similar protocols.
UART serial communication is characterized by a baudrate.
In python, the standard way of communicating with UART devices is the <a href=https://pypi.org/project/pyserial/?>pyserial</a> library.
We include in the yaqd-core-python implementation a subclass of the pyserial implementation that has some asynchronous functions avialable.
</p>
<p>
A typical <code>uses-uart</code> daemon will look something like:
</p>

<pre>
<code>
__all__ = ["ExampleUsesUart"]

import asyncio

from yaqd_core import Base, aserial

class ExampleUsesUart(Base):
    _kind = "example-uses-uart"
    traits = ["uses-uart", "uses-serial"]
    defaults = {"baud_rate": 9600}  # Check your device for appropriate default

    def __init__(self, name, config, config_filepath):
        super().__init__(name, config, config_filepath)
	self._serial_port = aserial.ASerial(config["serial_port"], config["baud_rate"])
	...
        # perfom other setup, possibly including reads and writes
    
    def close(self):
        self._serial_port.close()

    def direct_serial_write(self, message):
        self._busy = True
        self._serial_port.write(message.encode())

    async def update_state(self):
        while True:
	    self._serial_port.write(b"get_status")
	    line = await self._serial_port.readline()
	    self._busy = line != b"ready"
	    if self._busy:
	        await asyncio.sleep(0.1)
	    else:
	        await self._busy_sig.wait()
</code>
</pre>

<h3> Implementing <a href=https://yaq.fyi/traits/uses-i2c>uses-i2c</a> </h3>

<p>
There are many libraries in python that can manage low level i2c communication.
We have typically used <a href=https://pypi.org/project/smbus/>smbus</a>.
</p>
<p>
A typical <code>uses-i2c</code> daemon will look something like:
</p>
<pre>
<code>
__all__ = ["ExampleUsesI2c"]

import asyncio

from yaqd_core import Base, aserial

class ExampleUsesI2c(Base):
    _kind = "example-uses-i2c"
    traits = ["uses-i2c", "uses-serial"]
    defaults = {"i2c_addr": 0x60}  # Check your device for appropriate default

    def __init__(self, name, config, config_filepath):
        super().__init__(name, config, config_filepath)
	self.address = config["address"]
	self.bus = smbus.SMBus(1)
        ...
        # perfom other setup, possibly including reads and writes

    def direct_serial_write(self, message):
        self._busy = True
	for byte in bytes(message, encoding="utf-8"):
	    self.bus.write_byte(self.address, byte)

    async def update_state(self):
        while True:
            self.bus.write_byte(self.address, 0x12)
            data = self.bus.read_i2c_block_data(self.address, 0x00, 3)
            self._busy = data == 0x01
            if self._busy:
                await asyncio.sleep(0.1)
            else:
                await self._busy_sig.wait()
</code>
</pre>
{% include "footer.html" %}
